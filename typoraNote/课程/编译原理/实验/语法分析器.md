### 参考

> 1. [编译原理实验二：LL(1)语法分析器 - Chris-Zhang - 博客园 (cnblogs.com)](https://www.cnblogs.com/jiaqizhang/p/9879777.html)
> 2. [【编译原理】LL（1）语法分析器_老北京的热干面-CSDN博客_语法分析器](https://blog.csdn.net/qq_36946026/article/details/80273362)

### 测试数据

```java
空串:ε

请输入产生式的数目: 
8
E->TK  
K->+TK
K->ε
T->FM
M->*FM
M->ε
F->i
F->(E)
13
E->TA
A->+E
A->ε
T->FB
B->T
B->ε
F->PC
C->*C
C->ε
P->(E)
P->a
P->b
P->^
6
S->a
S->^
S->(T)
T->SŤ
Ť->,SŤ
Ť->ε
请输入所有的终结符的数目: 
7
+*i()#ε
9
+*()ab^#ε
7
#(),^aε
请输入所有的非终结符的数目: 
5
ETKFM
7
EATBFCP
3
STŤ
    
(a,a)
(a^a
(a)
FIRST集合:

E:[(, i]
T:[(, i]
K:[ε, +]
F:[(, i]
M:[ε, *]
/*
求Follow集的算法思想
1.遍历每一个右部包含非终结符x的产生式

2.如果x的下一个字符是终结符，添加进x的Follow集

3.如果x的下一个字符是非终结符，把该字符的First集加入x的Follow集（不能加入空串）

4.如果下一字符的First集有空串并且该产生式的左部不是x，则把左部的Follow集加入x的Follow集

5.如果x已经是产生式的末尾，则把左部的Follow集添加到x的Follow集里
*/
FOLLOW集合:

E:[#, )]
T:[#, ), +]
K:[#, )]
F:[#, ), *, +]
M:[#, ), +]
```

